<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Earth Flight Path</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; height: 100%; }
    canvas { display: block; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js"
      }
    }
  </script>
</head>
<body>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 3;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);

    // íŒŒëž€ ì§€êµ¬
    const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
    const earthMaterial = new THREE.MeshBasicMaterial({ color: 0x3399ff });
    const earth = new THREE.Mesh(earthGeometry, earthMaterial);
    scene.add(earth);

    // ìœ„ë„/ê²½ë„/ê³ ë„ â†’ 3D ìœ„ì¹˜ ë³€í™˜
    function latLonAltToVec3(lon, lat, alt) {
      const phi = (90 - lat) * Math.PI / 180;
      const theta = (lon + 180) * Math.PI / 180;
      const radius = 1 + alt;
      return new THREE.Vector3(
        radius * Math.sin(phi) * Math.cos(theta),
        radius * Math.cos(phi),
        radius * Math.sin(phi) * Math.sin(theta)
      );
    }

    // ë¹„í–‰ ê²½ë¡œ
    const flightPoints = [
      [-0.4543, 51.4700, 0.02],   // Heathrow
      [8.6821, 50.1109, 0.03],    // Frankfurt
      [2.3522, 48.8566, 0.04],    // Paris
      [7.2620, 43.7102, 0.05],    // Nice
      [12.4964, 41.9028, 0.06]    // Rome
    ];

    const flightGeometry = new THREE.BufferGeometry();
    const positions = [];

    flightPoints.forEach(([lon, lat, alt]) => {
      const pos = latLonAltToVec3(lon, lat, alt);
      positions.push(pos.x, pos.y, pos.z);
    });

    flightGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    const flightLine = new THREE.Line(
      flightGeometry,
      new THREE.LineBasicMaterial({ color: 0xff0000 })
    );
    scene.add(flightLine);

    // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // ðŸ‘‰ðŸ‘‰ðŸ‘‰ ì°½ í¬ê¸° ë³€ê²½ ëŒ€ì‘ ì½”ë“œ ì¶”ê°€!
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    // ðŸ‘ˆðŸ‘ˆðŸ‘ˆ ì—¬ê¸°ê¹Œì§€ ì¶”ê°€
  </script>
</body>
</html>
